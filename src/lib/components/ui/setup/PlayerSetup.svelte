<script lang="ts">
	import { _ } from 'svelte-i18n';
	import {
		PLAYER_COLORS,
		ALL_EDGES,
		type Player,
		type PlayerEdge,
		type GameMode
	} from '$lib/types';
	import { settings } from '$lib/stores';
	import X from 'lucide-svelte/icons/x';
	import Plus from 'lucide-svelte/icons/plus';
	import PanelBottomClose from 'lucide-svelte/icons/panel-bottom-close';
	import { slide } from 'svelte/transition';

	interface Props {
		mode?: GameMode | null;
		onPlayersChange?: (players: Player[], isSoloMode: boolean, isValid: boolean) => void;
		onAddPlayer?: () => void;
	}

	let { mode = null, onPlayersChange = () => {}, onAddPlayer }: Props = $props();

	let nameErrors = $state<Map<number, string>>(new Map());

	// Track which names are default (generated by us)
	let defaultNames = $state<Map<number, string>>(new Map());

	// Generate default player name
	function generateDefaultPlayerName(index: number): string {
		return $_('players.playerName', { values: { number: index + 1 } });
	}

	// Initialize players from settings (only once)
	let players = $state<Array<{ name: string; color: string; edge: PlayerEdge; rotation: number }>>(
		$settings.players.length > 0
			? $settings.players.map((p) => {
					const edge = p.edge || 'bottom';
					return { ...p, edge, rotation: ALL_EDGES.indexOf(edge) * 90 };
				})
			: [
					{
						name: generateDefaultPlayerName(0),
						color: PLAYER_COLORS[0],
						edge: 'bottom',
						rotation: 0
					}
				]
	);

	// Initialize default names map
	$effect(() => {
		// Set default names for initial players
		if (defaultNames.size === 0) {
			players.forEach((player, index) => {
				const defaultName = generateDefaultPlayerName(index);
				if (player.name === defaultName) {
					defaultNames.set(index, defaultName);
				}
			});
		}
	});

	// Auto-detect solo mode and notify parent when players change
	$effect(() => {
		const isSoloMode = players.length === 1;

		// Validate all names and update errors map
		const newErrors = new Map<number, string>();
		let allValid = true;

		players.forEach((p, i) => {
			const trimmedName = p.name.trim();
			if (!trimmedName) {
				newErrors.set(i, 'players.errors.nameRequired');
				allValid = false;
				return;
			}

			// Check for duplicates
			const duplicate = players.some(
				(other, otherIndex) =>
					otherIndex !== i && other.name.trim().toLowerCase() === trimmedName.toLowerCase()
			);

			if (duplicate) {
				newErrors.set(i, 'players.errors.duplicateName');
				allValid = false;
			}
		});

		// Update the errors map to trigger reactivity
		nameErrors = newErrors;

		const playersWithScore: Player[] = players.map((p) => ({
			name: p.name,
			color: p.color,
			edge: p.edge,
			score: 0
		}));

		// Save to settings only if all names are valid
		if (allValid) {
			settings.update((s) => ({
				...s,
				players: players.map((p) => ({ name: p.name, color: p.color, edge: p.edge }))
			}));
		}

		// Always notify parent, but include validation state
		onPlayersChange(playersWithScore, isSoloMode, allValid);
	});

	function removePlayer(index: number) {
		// Don't allow deleting the last player
		if (players.length <= 1) return;
		players = players.filter((_, i) => i !== index);
	}

	// Get the edge with the least amount of players
	function getDefaultEdge(): PlayerEdge {
		if (players.length === 1 && players[0].edge === 'bottom') {
			return 'top';
		}

		const edgeCounts = new Map<PlayerEdge, number>();
		ALL_EDGES.forEach((edge) => edgeCounts.set(edge, 0));

		players.forEach((p) => {
			edgeCounts.set(p.edge, (edgeCounts.get(p.edge) || 0) + 1);
		});

		// Find edge with minimum count
		let minEdge: PlayerEdge = 'bottom';
		let minCount = Infinity;
		ALL_EDGES.forEach((edge) => {
			const count = edgeCounts.get(edge) || 0;
			if (count < minCount) {
				minCount = count;
				minEdge = edge;
			}
		});

		return minEdge;
	}

	// Toggle edge in clockwise order: bottom -> left -> top -> right -> bottom
	function toggleEdge(index: number) {
		const currentEdge = players[index].edge;
		const currentIndex = ALL_EDGES.indexOf(currentEdge);
		const nextIndex = (currentIndex + 1) % ALL_EDGES.length;
		players[index].edge = ALL_EDGES[nextIndex];
		players[index].rotation = (players[index].rotation ?? currentIndex * 90) + 90;
	}

	// Export addPlayer function for external use
	export function addPlayer() {
		if (players.length >= 10) return;

		// Generate a unique default name
		const defaultName = generateDefaultPlayerName(players.length);
		const edge = getDefaultEdge();

		const newPlayer = {
			name: defaultName,
			color: PLAYER_COLORS[players.length % PLAYER_COLORS.length],
			edge,
			rotation: ALL_EDGES.indexOf(edge) * 90
		};
		players = [...players, newPlayer];

		// Edge-case: with 3 players, prefer bottom, left, top over bottom, top, left
		if (
			players.length === 3 &&
			players[0].edge === 'bottom' &&
			players[1].edge === 'top' &&
			players[2].edge === 'left'
		) {
			players[1].edge = 'left';
			players[2].edge = 'top';
			players[1].rotation = ALL_EDGES.indexOf('left') * 90;
			players[2].rotation = ALL_EDGES.indexOf('top') * 90;
		}

		// Mark this name as default
		defaultNames.set(players.length - 1, defaultName);

		onAddPlayer?.();
	}

	function handleFocus(index: number) {
		// If this is a default name, clear it
		if (defaultNames.has(index) && players[index].name === defaultNames.get(index)) {
			players[index].name = '';
		}
	}

	function handleBlur(index: number) {
		// If the name is empty, restore the default name
		if (players[index].name.trim() === '') {
			const defaultName = defaultNames.get(index) || generateDefaultPlayerName(index);
			players[index].name = defaultName;
			defaultNames.set(index, defaultName);
		} else {
			// User entered a custom name, remove from default names
			defaultNames.delete(index);
		}
	}
</script>

<div class="flex w-full flex-col gap-2">
	<!-- Players List -->
	{#each players as player, index (index)}
		<div class="flex flex-col gap-1" transition:slide={{ duration: 300 }}>
			<div class="flex items-center gap-2">
				<!-- Edge Icon Button (Timeline mode only) -->
				{#if mode === 'timeline'}
					<button
						type="button"
						onclick={() => toggleEdge(index)}
						class="shrink-0 cursor-pointer rounded-md border-none bg-slate-800 p-1.5 text-cyan-400 transition-all duration-200 hover:bg-cyan-400/10 hover:text-cyan-300"
						aria-label={$_('players.edge.toggle')}
						title={$_(`players.edge.${player.edge}`)}
					>
						<PanelBottomClose
							class="h-4 w-4 origin-center transition-transform duration-200 ease-in-out"
							style={`transform: rotate(${player.rotation}deg);`}
						/>
					</button>
				{/if}

				<!-- Player Name Input -->
				<input
					type="text"
					bind:value={player.name}
					onfocus={() => handleFocus(index)}
					onblur={() => handleBlur(index)}
					placeholder={$_('players.nameLabel')}
					class="flex-1 rounded-lg border px-3 py-1.5 text-sm font-semibold text-white transition-colors duration-200 outline-none focus:border-cyan-400 {nameErrors.has(
						index
					)
						? 'border-red-500!'
						: 'border-slate-700'}"
					maxlength="20"
				/>

				<!-- Color -->
				<!-- <button
					type="button"
					class="h-6 w-6 shrink-0 cursor-pointer rounded-full border-2 border-white p-0 transition-transform duration-200 hover:scale-110"
					style="background-color: {player.color};"
					aria-label="Choose color"
				></button> -->

				<!-- Remove Button (disabled if only one player) -->
				<button
					type="button"
					onclick={() => removePlayer(index)}
					class="shrink-0 cursor-pointer rounded-md border-none bg-slate-800 p-1 text-cyan-400 transition-all duration-200 hover:bg-cyan-400/10 hover:text-cyan-300 disabled:cursor-not-allowed disabled:opacity-20 disabled:hover:bg-transparent"
					aria-label="Remove player"
					disabled={players.length <= 1}
				>
					<X class="h-4 w-4" />
				</button>
			</div>
			{#if nameErrors.has(index)}
				<p class="pl-1 text-xs text-red-400">
					{$_(nameErrors.get(index) || '')}
				</p>
			{/if}
		</div>
	{/each}
</div>

<!-- Add Player Button - Exported for external use -->
{#if onAddPlayer === undefined}
	{#if players.length < 10}
		<button
			type="button"
			onclick={addPlayer}
			class="flex w-full cursor-pointer items-center justify-center gap-2 rounded-lg border border-dashed border-slate-700 bg-transparent p-2 text-sm text-slate-500 transition-all duration-200 hover:border-cyan-400 hover:text-cyan-400"
		>
			<Plus class="h-4 w-4" />
			{$_('players.addPlayer')}
		</button>
	{/if}
{/if}
